{{ define "article_02" }}

    <!DOCTYPE html>
    <html lang="en">

    {{template "head"}}

    <body class="d-flex flex-column h-100">
    <!-- Begin page content -->
    <main role="main" class="flex-shrink-0">
        <div class="container">
            <div class="mt-3">
                <p>JoeObarzanek.com</p>
                <nav aria-label="breadcrumb">
                    <ol class="breadcrumb">
                        <li class="breadcrumb-item"><a href="/">Home</a></li>
                        <li class="breadcrumb-item"><a href="/articles">Articles</a></li>
                        <li class="breadcrumb-item"><a href="/projects">Projects</a></li>
                        <li class="breadcrumb-item"><a href="/resume">Resume</a></li>
                    </ol>
                </nav>
            </div>
            <hr>
            <!-- Begin article -->
            <div class="text-center">
                <p class="lead title">PyTesseract: multithreading vs multiprocessing</p>
                <img alt="tesseract_and_python_multi" src="../static/img/articles/jobarzanek_tesseract_python_multi.png">
            </div>
            <div class="mt-2 mb-5">
                <div class="bg-light rounded">
                    <p class="text-muted p-2">July 10, 2020<span class="float-right">~10 min</span></p>
                </div>
                <p>
                    Recently, I was tasked with optimizing a "Financial Spreading" application at work. In a nutshell,
                    the application assists the user, a credit analyst, in evaluating the "credit worthiness" of the customer
                    by extracting data from various financial PDF documents uploaded by the credit analyst.
                    To do so, the app leverages the open source OCR engine from Google —
                    <strong><a target="_blank" href="https://github.com/tesseract-ocr/tesseract">Tesseract</a></strong>.
                </p>
                <p>
                    While the app was more than capable of providing insights to the credit analyst, the time
                    from uploading a PDF to displaying "usable" information from the same PDF was incredibly slow and
                    impacting downstream credit assessment workflows. The slowness mostly stemmed from how the OCR methods
                    were implemented within the app — essentially a <code>for</code> loop was iterating over anywhere from 10 to
                    100 PDF pages and calling a method from the <code>pytesseract</code>
                    library on each one by one. While this approach was "atomic" and safe from any parallelism
                    pitfalls like race conditions, the design needed to change in order to improve the app's performance.
                </p>
                <p>
                    If you're familiar with Python's relationship with the GIL, concurrency, and parallelism, then like
                    me you're first thoughts may have been: "Hmm would <code>threading</code> or <code>multiprocessing</code>
                    be better here? It seems like OCR is a pretty CPU heavy task. I bet this would be a great opportunity
                    to leverage true parallelism via the <code>multiprocessing</code> library." After doing a few Google
                    searches along the lines of <i>"OCR with python pytesseract and multiprocessing"</i>, I came across
                    pretty solid
                    <a target="_blank" href="https://appliedmachinelearning.blog/2018/06/30/performing-ocr-by-running-parallel-instances-of-tesseract-4-0-python/">
                        article</a>
                    explaining how to implement a multiprocessing pool with pytesseract.
                    Confident in this approach, I decided to move forward with a convenient "OCRProcessManager" class to handle
                    dividing and running the OCR pieces of the application in parallel with multiple processes.
                </p>
                <p>
                    After writing a decent amount of code, things were working surprisingly well. My code would split a large
                    list of images into smaller chunks and pass them off to individuals processes to be <i>OCR'd</i> by Tesseract
                    — and it was much faster! However, the fact that I didn't know how the OCR code was processing images
                    under the hood really started to bug me. Having a rough understanding of how my python code was
                    interacting with the Tesseract engine behind the scenes had big implications for the multiprocessing
                    design. Also, I'll be the first to admit - working with many processes is difficult. Things like logging or even
                    simple communication between processes needs to be somewhat re-worked when using processes vs threads.
                    Overall, I reasoned I should at least conduct a small investigation to make sure the multiprocessing
                    approach was indeed the best way to proceed.
                </p>
                <p>
                    To start, I wanted to see if <code>pytesseract</code> was a pure Python or Cython implementation
                    of Tesseract. Many scientific or computation heavy libraries in Python (NumPy, Pandas, SciPy, etc.)
                    utilize Cython (a C-extension for Python) as a means of leveraging the speed of C with the readability
                    of Python because Cython has a few tools that allow it to run code without the having to worry about the GIL.
                    (<a href="https://lbolla.info/python-threads-cython-gil">Overcoming Python's GIL with Cython</a>).
                    Anyway, I went over to <a href="https://github.com/madmaze/pytesseract">pytesseract's homepage</a>
                    to check the source code and almost immediately I spotted something interesting — pytesseract is just
                    a simple Python wrapper around the Tesseract C++ binary invoked via a call to <code>subprocess.Popen()</code> ...
                </p>
                <script src="https://gist.github.com/pogzyb/9c5a90a231b8c45ebbda5b85d766da8f.js"></script>
                <p>
                    By design <code>subprocess.Popen()</code> will open another separate "process" with its own system state,
                    memory, files, program counter, and a call stack used to hold the local variables of functions for whatever
                    program is being run. Python's GIL does not span multiple processes, so in theory two separate calls to one
                    of pytesseract's OCR methods whether called via a thread or process would "run in parallel". The question
                    I then asked myself was: "Why should I need to run pytesseract in a separate process when it will
                    just open another process of its own?".
                </p>
                <p>
                    Next, I discovered that pytesseract will also write (to /tmp) any image you pass to it ...
                </p>
                <script src="https://gist.github.com/pogzyb/d97f9853f67a6cf0fef56b48a0819b82.js"></script>
                <p>
                    The reading and writing I/O between pytesseract and the tesseract binary creates unavoidable latency.
                    It wouldn't be reasonable to swap out pytesseract for a different Python Tesseract library at this point
                    in the application's life, so this was just something I'd have to deal with. Also, for what it's worth
                    pytesseract is actually a very easy to use library despite some of these clunky features.
                </p>
                <div class="rounded bg-light">
                    <h6 class="p-1 mb-0 text-white rounded bg-info">Note:</h6>
                    <p class="p-2">
                        <small>
                            While writing this article, I found <code>tesserocr</code>, which "integrates directly with
                            Tesseract's C++ API using Cython". I haven't had the opportunity to use this package; however,
                            given the description I'd assume it's a much faster Python interface for Tesseract.
                            Check out the project here: <a href="https://github.com/sirfz/tesserocr">
                                github.com/sirfz/tesserocr</a>
                        </small>
                    </p>
                </div>
                <p>
                    With these new finds, I decided it would be a good idea to run a simple experiment to compare threading
                    and multiprocessing implementations of pytesseract's <code>image_to_data()</code> method. My hypothesis
                    was "Given that pytesseract utilizes <code>subprocess.Popen()</code>, threads should be able to
                    outperform processes". Some functions Python interpreter will actually release the GIL and invoking a call to
                    <code>subprocess.Popen()</code> happens to be one of them. This means that while a .
                    Another supporting piece of evidence for my hypothesis is the fact that processes are "heavier" than
                    threads.
                </p>
                <div class="rounded bg-light">
                    <h6 class="p-1 mb-0 text-white rounded bg-secondary">Workstation Specs:</h6>
                    <p class="p-2">
                        <small>
                        Model: Dell XPS 13 9350<br>
                        Processor: Intel Skylake Core i7-6560U CPU, dual-core 2.2 GHz(3.2Ghz boost)<br>
                        Memory: 16 GB LPDDR3 1866Mhz
                        OS: Windows 10 **Running Docker Desktop**
                        </small>
                    </p>
                </div>
                <p>
                    I gathered a dataset of 128 PDF images that I'd feed to a pretty simple python script.
                </p>

                <p>A good visual of the differences between running threads vs processes is depicted in the images below. </p>
                <img alt="tesseract_and_python_multi" class="w-100" src="../static/img/articles/processing-tesseract.png">
                <p></p>
                <img alt="tesseract_and_python_multi" class="w-100" src="../static/img/articles/threading-tesseract.png">
                <p>The results were surprising</p>
                <img alt="tesseract_and_python_multi" class="w-100" src="../static/img/articles/comparison.png">
                <p>The next challenge I have to tackle is finding</p>
            </div>
        </div>
    </main>
    {{template "js"}}
    </body>

    </html>

{{ end }}